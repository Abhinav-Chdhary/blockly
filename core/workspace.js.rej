***************
*** 26,31 ****
  
  goog.provide('Blockly.Workspace');
  
  // TODO(scr): Fix circular dependencies
  // goog.require('Blockly.Block');
  goog.require('Blockly.ScrollbarPair');
--- 26,33 ----
  
  goog.provide('Blockly.Workspace');
  
+ goog.require('Blockly.Instrument'); // lyn's instrumentation code
+ 
  // TODO(scr): Fix circular dependencies
  // goog.require('Blockly.Block');
  goog.require('Blockly.ScrollbarPair');
***************
*** 90,95 ****
  Blockly.Workspace.prototype.trashcan = null;
  
  /**
   * PID of upcoming firing of a change event.  Used to fire only one event
   * after multiple changes.
   * @type {?number}
--- 92,103 ----
  Blockly.Workspace.prototype.trashcan = null;
  
  /**
+  * The workspace's warning indicator.
+  * @type {Blockly.WarningIndicator}
+  */
+ Blockly.Workspace.prototype.warningIndicator = null;
+ 
+ /**
   * PID of upcoming firing of a change event.  Used to fire only one event
   * after multiple changes.
   * @type {?number}
***************
*** 144,149 ****
  };
  
  /**
   * Get the SVG element that forms the drawing surface.
   * @return {!Element} SVG element.
   */
--- 156,175 ----
  };
  
  /**
+  * Adds the warning indicator.
+  * @param {!Function} getMetrics A function that returns workspace's metrics.
+  */
+ Blockly.Workspace.prototype.addWarningIndicator = function(getMetrics) {
+   if (Blockly.WarningIndicator && !this.readOnly) {
+     this.warningIndicator = new Blockly.WarningIndicator(getMetrics);
+     var svgWarningIndicator = this.warningIndicator.createDom();
+     this.svgGroup_.insertBefore(svgWarningIndicator, this.svgBlockCanvas_);
+     this.warningIndicator.init();
+   }
+ };
+ 
+ 
+ /**
   * Get the SVG element that forms the drawing surface.
   * @return {!Element} SVG element.
   */
***************
*** 164,169 ****
   * @param {!Blockly.Block} block Block to remove.
   */
  Blockly.Workspace.prototype.addTopBlock = function(block) {
    this.topBlocks_.push(block);
    if (Blockly.Realtime.isEnabled() && this == Blockly.mainWorkspace) {
      Blockly.Realtime.addTopBlock(block);
--- 190,197 ----
   * @param {!Blockly.Block} block Block to remove.
   */
  Blockly.Workspace.prototype.addTopBlock = function(block) {
+   if (block.workspace == Blockly.mainWorkspace) //Do not reset arrangements for the flyout
+     Blockly.resetWorkspaceArrangements();
    this.topBlocks_.push(block);
    if (Blockly.Realtime.isEnabled() && this == Blockly.mainWorkspace) {
      Blockly.Realtime.addTopBlock(block);
***************
*** 177,186 ****
   * @return {!Array.<!Blockly.Block>} Array of blocks.
   */
  Blockly.Workspace.prototype.getAllBlocks = function() {
    var blocks = this.getTopBlocks(false);
-   for (var x = 0; x < blocks.length; x++) {
      blocks.push.apply(blocks, blocks[x].getChildren());
    }
    return blocks;
  };
  
--- 212,242 ----
   * @return {!Array.<!Blockly.Block>} Array of blocks.
   */
  Blockly.Workspace.prototype.getAllBlocks = function() {
+   var start = new Date().getTime(); //*** lyn instrumentation
    var blocks = this.getTopBlocks(false);
+   Blockly.Instrument.stats.getAllBlocksAllocationCalls++;
+   if (Blockly.Instrument.useLynGetAllBlocksFix) {
+     // Lyn's version of getAllBlocks that avoids quadratic times for large numbers of blocks
+     // by mutating existing blocks array rather than creating new ones
+     for (var x = 0; x < blocks.length; x++) {
+       var children = blocks[x].getChildren();
+       blocks.push.apply(blocks, children);
+       Blockly.Instrument.stats.getAllBlocksAllocationSpace += children.length;
+     }
+   } else {
+     // Neil's version that has quadratic time for large number of blocks
+     // because each call to concat creates *new* array, and so this code does a *lot* of heap
+     // allocation when there are a large number of blocks.
+     for (var x = 0; x < blocks.length; x++) {
      blocks.push.apply(blocks, blocks[x].getChildren());
+       Blockly.Instrument.stats.getAllBlocksAllocationCalls++;
+       Blockly.Instrument.stats.getAllBlocksAllocationSpace += blocks.length;
+     }
    }
+   var stop = new Date().getTime(); //*** lyn instrumentation
+   var timeDiff = stop - start; //*** lyn instrumentation
+   Blockly.Instrument.stats.getAllBlocksCalls++;
+   Blockly.Instrument.stats.getAllBlocksTime += timeDiff;
    return blocks;
  };
  
***************
*** 198,209 ****
   * Render all blocks in workspace.
   */
  Blockly.Workspace.prototype.render = function() {
-   var renderList = this.getAllBlocks();
-   for (var x = 0, block; block = renderList[x]; x++) {
-     if (!block.getChildren().length) {
-       block.render();
      }
    }
  };
  
  /**
--- 254,286 ----
   * Render all blocks in workspace.
   */
  Blockly.Workspace.prototype.render = function() {
+   var start = new Date().getTime();
+   // [lyn, 04/08/14] Get both top and all blocks for stats
+   var topBlocks = this.getTopBlocks();
+   var allBlocks = this.getAllBlocks();
+   if (Blockly.Instrument.useRenderDown) {
+     for (var t = 0, topBlock; topBlock = topBlocks[t]; t++) {
+       Blockly.Instrument.timer(
+           function () { topBlock.renderDown(); },
+           function (result, timeDiffInner) {
+             Blockly.Instrument.stats.renderDownTime += timeDiffInner;
+           }
+       );
+     }
+   } else {
+     var renderList = allBlocks;
+     for (var x = 0, block; block = renderList[x]; x++) {
+       if (!block.getChildren().length) {
+         block.render();
+       }
      }
    }
+   var stop = new Date().getTime();
+   var timeDiffOuter = stop - start;
+   Blockly.Instrument.stats.blockCount = allBlocks.length;
+   Blockly.Instrument.stats.topBlockCount = topBlocks.length;
+   Blockly.Instrument.stats.workspaceRenderCalls++;
+   Blockly.Instrument.stats.workspaceRenderTime += timeDiffOuter;
  };
  
  /**
